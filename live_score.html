<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Live Score Admin — We Are Eleven</title>
  <script src="https://cdn.tailwindcss.com"></script>
  <style>
    html, body { background: #0b1220; color: #e5e7eb; }
    .glass { backdrop-filter: blur(10px); background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.08); }
    .chip { border: 1px solid rgba(255,255,255,0.18); background: rgba(255,255,255,0.08); }
    .btn { @apply px-3 py-2 rounded-xl font-semibold; }
    .btn-ghost { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.16); }
    .btn-prim { background: #22c55e; color: #0b1220; }
    .btn-warn { background: #ef4444; color: white; }
    .muted { color: #a7b0bf; }
    select, input, button { outline: none; }
    select, input { background: rgba(255,255,255,0.06); border: 1px solid rgba(255,255,255,0.14); }
  </style>
</head>
<body class="min-h-screen">
  <div class="max-w-5xl mx-auto p-4 sm:p-6 space-y-6">
    <header class="flex items-center justify-between">
      <h1 class="text-2xl sm:text-3xl font-bold">Live Score Admin</h1>
      <span id="envBadge" class="chip px-3 py-1 rounded-full text-sm">Firestore Connected</span>
    </header>

    <!-- Match picker / meta -->
    <section class="glass rounded-2xl p-4 sm:p-5 space-y-4">
      <div class="grid grid-cols-1 sm:grid-cols-2 gap-3 items-center">
        <div>
          <label class="block text-sm muted mb-1">Select Match</label>
          <select id="matchSelect" class="w-full p-2 rounded-xl" ></select>
        </div>
        <div class="flex gap-2 flex-wrap items-end sm:justify-end">
          <span id="metaHomeAway" class="chip px-3 py-1 rounded-full text-sm">—</span>
          <span id="metaStageDay" class="chip px-3 py-1 rounded-full text-sm">—</span>
          <span id="metaDoc" class="chip px-3 py-1 rounded-full text-sm">—</span>
        </div>
      </div>
    </section>

    <!-- Scoreboard -->
    <section class="glass rounded-2xl p-5 sm:p-7">
      <div id="scoreboard" class="grid grid-cols-1 gap-6">
        <div class="grid grid-cols-1 sm:grid-cols-3 items-center gap-4">
          <div class="text-center sm:text-right">
            <div class="text-xs uppercase tracking-wider muted">Home</div>
            <div id="homeName" class="text-xl sm:text-2xl font-bold">—</div>
          </div>
          <div class="text-center">
            <div class="text-xs uppercase tracking-wider muted">Score</div>
            <div class="text-4xl sm:text-6xl font-extrabold" id="scoreText">0 — 0</div>
          </div>
          <div class="text-center sm:text-left">
            <div class="text-xs uppercase tracking-wider muted">Away</div>
            <div id="awayName" class="text-xl sm:text-2xl font-bold">—</div>
          </div>
        </div>

        <div class="grid grid-cols-2 sm:grid-cols-4 gap-3">
          <button id="incHome" class="btn btn-prim rounded-2xl">+1 Home</button>
          <button id="decHome" class="btn btn-ghost rounded-2xl">-1 Home</button>
          <button id="incAway" class="btn btn-prim rounded-2xl">+1 Away</button>
          <button id="decAway" class="btn btn-ghost rounded-2xl">-1 Away</button>
        </div>

        <div class="flex gap-3 flex-wrap">
          <button id="resetScore" class="btn btn-warn rounded-2xl">Reset to 0–0</button>
          <button id="swapSides" class="btn btn-ghost rounded-2xl">Swap Home/Away (reverse leg)</button>
        </div>
      </div>
    </section>

    <!-- Create / manage match -->
    <section class="glass rounded-2xl p-5 sm:p-7 space-y-4">
      <h2 class="text-lg font-semibold">Create New Match</h2>
      <div class="grid grid-cols-1 sm:grid-cols-2 gap-4">
        <div>
          <label class="block text-sm muted mb-1">Home Team</label>
          <input id="homeInput" class="w-full p-2 rounded-xl" placeholder="Thunderbolt" />
        </div>
        <div>
          <label class="block text-sm muted mb-1">Away Team</label>
          <input id="awayInput" class="w-full p-2 rounded-xl" placeholder="Messiah FC" />
        </div>
        <div>
          <label class="block text-sm muted mb-1">Matchday (optional)</label>
          <input id="mdInput" type="number" min="1" class="w-full p-2 rounded-xl" placeholder="1" />
        </div>
        <div>
          <label class="block text-sm muted mb-1">Stage (optional)</label>
          <input id="stageInput" class="w-full p-2 rounded-xl" placeholder="Group A / QF / SF / Final" />
        </div>
      </div>
      <div class="flex gap-3">
        <button id="btnCreate" class="btn btn-prim rounded-2xl">Create Match</button>
        <button id="btnDelete" class="btn btn-ghost rounded-2xl">Delete Selected</button>
      </div>
      <p class="muted text-sm">Tip: Use <span class="font-mono">Swap Home/Away</span> on an existing doc to prepare the reverse leg, then change Matchday or Stage and hit Create to make a new document.</p>
    </section>
  </div>

  <!-- Firebase (Modular SDK) -->
  <script type="module">
    import { initializeApp } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-app.js";
    import { getFirestore, collection, doc, setDoc, updateDoc, getDoc, addDoc, deleteDoc,
             onSnapshot, query, orderBy, serverTimestamp, increment, getDocs, where, limit } from "https://www.gstatic.com/firebasejs/10.12.0/firebase-firestore.js";

    // --- Firebase config wiring ---
// We try, in order:
// 1) ./firebase-config.js exporting `firebaseConfig`
// 2) window.FIREBASE_CONFIG (if you set it in a <script>)
// 3) Fallback placeholders (edit inline if you prefer)
let firebaseConfig = null;
try {
  const mod = await import('./firebase-config.js');
  if (mod && mod.firebaseConfig) {
    firebaseConfig = mod.firebaseConfig;
    console.log('[Firebase] Using config from ./firebase-config.js');
  }
} catch (e) {
  // ignore; file likely doesn't exist
}
if (!firebaseConfig && window.FIREBASE_CONFIG) {
  firebaseConfig = window.FIREBASE_CONFIG;
  console.log('[Firebase] Using config from window.FIREBASE_CONFIG');
}
if (!firebaseConfig) {
  console.warn('[Firebase] Using inline fallback config. Replace with your real keys.');
  firebaseConfig = {
    apiKey: "AIzaSyB0DaaYB1hZLY8h23QOpT7Ok4sX5ACkHTM",
    authDomain: "we-are-eleven.firebaseapp.com",
    projectId: "we-are-eleven",
    storageBucket: "we-are-eleven.firebasestorage.app",
    messagingSenderId: "446706356039",
    appId: "1:446706356039:web:54cc424f2a8178ae824662",
    measurementId: "G-CX1LHHXBDQ"
  };
}

const app = initializeApp(firebaseConfig);
    const db  = getFirestore(app);

    // Elements
    const els = {
      matchSelect: document.getElementById('matchSelect'),
      metaHomeAway: document.getElementById('metaHomeAway'),
      metaStageDay: document.getElementById('metaStageDay'),
      metaDoc: document.getElementById('metaDoc'),
      homeName: document.getElementById('homeName'),
      awayName: document.getElementById('awayName'),
      scoreText: document.getElementById('scoreText'),
      incHome: document.getElementById('incHome'),
      decHome: document.getElementById('decHome'),
      incAway: document.getElementById('incAway'),
      decAway: document.getElementById('decAway'),
      resetScore: document.getElementById('resetScore'),
      swapSides: document.getElementById('swapSides'),
      homeInput: document.getElementById('homeInput'),
      awayInput: document.getElementById('awayInput'),
      mdInput: document.getElementById('mdInput'),
      stageInput: document.getElementById('stageInput'),
      btnCreate: document.getElementById('btnCreate'),
      btnDelete: document.getElementById('btnDelete'),
    };

    // URL prefill (e.g., ?matchday=1&stage=Group%20A)
    const url = new URL(location.href);
    let prefillMatchday = url.searchParams.get('matchday');
    let prefillStage    = url.searchParams.get('stage');

    // State
    let currentMatchId = null;
    let unsubMatch = null;

    // Helpers
    const fmtId = (id) => id ? '…' + id.slice(-6) : '—';
    const slugify = (s) => (s || '').toLowerCase().trim().replace(/\s+/g,'-').replace(/[^a-z0-9\-:]/g,'');

    function renderMeta(data, id) {
      const home = data?.homeTeam || data?.teamNames?.team1 || '—';
      const away = data?.awayTeam || data?.teamNames?.team2 || '—';
      els.metaHomeAway.textContent = `Home: ${home} • Away: ${away}`;

      const md = (data?.matchday !== undefined && data?.matchday !== null) ? `MD ${data.matchday}` : null;
      const st = data?.stage ? data.stage : null;
      els.metaStageDay.textContent = [st, md].filter(Boolean).join(' • ') || '—';
      els.metaDoc.textContent = `Doc ${fmtId(id)}`;

      els.homeName.textContent = home;
      els.awayName.textContent = away;

      const s1 = data?.scores?.team1 ?? 0;
      const s2 = data?.scores?.team2 ?? 0;
      els.scoreText.textContent = `${s1} — ${s2}`;
    }

    function setButtonsEnabled(enabled) {
      [els.incHome, els.decHome, els.incAway, els.decAway, els.resetScore, els.swapSides, els.btnDelete]
        .forEach(b => { b.disabled = !enabled; b.style.opacity = enabled ? 1 : 0.5; });
    }

    // Listen to match collection (for select)
    function listenToMatchList() {
      const qy = query(collection(db, 'matches'), orderBy('created', 'desc'));
      onSnapshot(qy, (snap) => {
        // Preserve current selection if possible
        const keep = els.matchSelect.value;
        els.matchSelect.innerHTML = '';
        snap.forEach((d) => {
          const data = d.data();
          const t1 = data?.homeTeam || data?.teamNames?.team1 || 'Home';
          const t2 = data?.awayTeam || data?.teamNames?.team2 || 'Away';
          const tag = data?.stage ? ` • ${data.stage}` : (data?.matchday ? ` • MD ${data.matchday}` : '');
          const opt = document.createElement('option');
          opt.value = d.id;
          opt.textContent = `${t1} vs ${t2}${tag} • ${fmtId(d.id)}`;
          els.matchSelect.appendChild(opt);
        });
        if (snap.size === 0) {
          const opt = document.createElement('option');
          opt.value = '';
          opt.textContent = 'No matches yet';
          els.matchSelect.appendChild(opt);
          setButtonsEnabled(false);
          currentMatchId = null;
          return;
        }
        // Restore selection or pick first
        const target = keep && [...els.matchSelect.options].some(o => o.value === keep) ? keep : els.matchSelect.options[0].value;
        els.matchSelect.value = target;
        selectMatch(target);
      });
    }

    // Listen to a single match doc
    function listenToMatchDoc(matchId) {
      if (unsubMatch) unsubMatch();
      const ref = doc(db, 'matches', matchId);
      unsubMatch = onSnapshot(ref, (d) => {
        if (!d.exists()) return;
        renderMeta(d.data(), d.id);
        setButtonsEnabled(true);
      });
    }

    async function selectMatch(matchId) {
      if (!matchId) return;
      currentMatchId = matchId;
      listenToMatchDoc(matchId);

      const ref = doc(db, 'matches', matchId);
      const s = await getDoc(ref);
      if (s.exists()) {
        const data = s.data();
        // One-time fill from URL ONLY if the field is missing
        const update = {};
        let needsUpdate = false;
        if ((data.matchday === undefined || data.matchday === null) && (prefillMatchday !== null && prefillMatchday !== '')) {
          update.matchday = Number(prefillMatchday);
          needsUpdate = true;
        }
        if ((!data.stage || data.stage === '') && (prefillStage && prefillStage !== '')) {
          update.stage = prefillStage;
          needsUpdate = true;
        }
        if (needsUpdate) {
          await updateDoc(ref, { ...update, updated: serverTimestamp() });
        }
        // IMPORTANT: clear prefill so it can't bleed into other matches
        prefillMatchday = null;
        prefillStage = null;
      }
    }

    // Score ops (always mutate scores.team1/team2 only)
    async function addScore(side, delta) {
      if (!currentMatchId) return;
      const ref = doc(db, 'matches', currentMatchId);
      await updateDoc(ref, {
        [`scores.${side}`]: increment(delta),
        updated: serverTimestamp()
      });
    }

    async function resetScores() {
      if (!currentMatchId) return;
      const ref = doc(db, 'matches', currentMatchId);
      await updateDoc(ref, {
        'scores.team1': 0,
        'scores.team2': 0,
        updated: serverTimestamp()
      });
    }

    async function swapHomeAway() {
      if (!currentMatchId) return;
      const ref = doc(db, 'matches', currentMatchId);
      const snap = await getDoc(ref);
      if (!snap.exists()) return;
      const d = snap.data();
      const newHome = d?.awayTeam || d?.teamNames?.team2;
      const newAway = d?.homeTeam || d?.teamNames?.team1;

      await updateDoc(ref, {
        homeTeam: newHome,
        awayTeam: newAway,
        teamNames: { team1: newHome, team2: newAway }, // keep UI consistent
        updated: serverTimestamp()
      });
    }

    // Create / Delete
    async function createMatch() {
      const home = els.homeInput.value.trim();
      const away = els.awayInput.value.trim();
      const md   = els.mdInput.value ? Number(els.mdInput.value) : null;
      const st   = els.stageInput.value.trim() || null;
      if (!home || !away) { alert('Please enter both Home and Away team names.'); return; }

      // Unique slug: matchday::home::away (or stage::home::away)
      const slug = `${md !== null ? 'md' + md : (st || 'na')}::${home}::${away}`.toLowerCase();
      const exists = await getDocs(query(collection(db, 'matches'), where('slug','==', slug), limit(1)));
      if (!exists.empty) {
        // Focus existing document
        const id = exists.docs[0].id;
        els.matchSelect.value = id;
        await selectMatch(id);
        return;
      }

      const payload = {
        homeTeam: home,
        awayTeam: away,
        teamNames: { team1: home, team2: away },
        scores: { team1: 0, team2: 0 },
        matchday: md,
        stage: st,
        slug: slugify(slug),
        created: serverTimestamp(),
        updated: serverTimestamp()
      };
      const col = collection(db, 'matches');
      const newRef = await addDoc(col, payload);
      els.matchSelect.value = newRef.id;
      await selectMatch(newRef.id);

      // Clear inputs for next create
      els.homeInput.value = '';
      els.awayInput.value = '';
      els.mdInput.value = '';
      els.stageInput.value = '';
    }

    async function deleteSelected() {
      if (!currentMatchId) return;
      if (!confirm('Delete this match document permanently?')) return;
      await deleteDoc(doc(db, 'matches', currentMatchId));
      currentMatchId = null;
      setButtonsEnabled(false);
    }

    // Wire UI
    els.matchSelect.addEventListener('change', (e) => selectMatch(e.target.value));
    els.incHome.addEventListener('click', () => addScore('team1', +1));
    els.decHome.addEventListener('click', () => addScore('team1', -1));
    els.incAway.addEventListener('click', () => addScore('team2', +1));
    els.decAway.addEventListener('click', () => addScore('team2', -1));
    els.resetScore.addEventListener('click', resetScores);
    els.swapSides.addEventListener('click', swapHomeAway);
    els.btnCreate.addEventListener('click', createMatch);
    els.btnDelete.addEventListener('click', deleteSelected);

    // Boot
    setButtonsEnabled(false);
    listenToMatchList();
  </script>
</body>
</html>
